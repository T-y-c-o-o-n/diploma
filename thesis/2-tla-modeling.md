# Глава 2. Tla+ cпецификации

Для проверки корректности алгоритма репликации движков необходимо написать спецификацию на TLA+. В введении было сказано про проблемы у спецификаций и соответствующих им TLC моделей. Во-первых, описание системы на языке TLA+ может быть слишком абстрактным и не похожим на реальный код. Во-вторых граф состояний в TLC модели может быть слишком большим из-за, наоборот, очень подробной модели. Поэтому хочется написать 2 спецификации, детальную, для большего соответствия коду, и абстрактную, для проверки свойств.

## 2.1. Различия спецификаций

Хочется, чтобы абстрактная модель задавала то, что происходит в системе. Например, мастер добавляет новый запрос пользователя, реплика копирует с мастера этот запрос, или нода становится лидером, выбирая лучшую цепочку. А детальная спецификация должна показывать то, как это происходит. Одна декларативно описывает "что", вторая описывает "как".

Основная идея состоит в том, чтобы в абстрактной спецификации не было сообщений между репликами, а в детальной они были. Тогда в первой переменные с состояними машин будут обмениваться значениями друг с другом напрямую - реплики копировать лог мастера, например - а вторая будет отвечать на вопрос, как они это делают - через сообщения.

## 2.2 Абстрактная спецификация

Вначале приведена абстрактная спецификация.

## 2.2.1 Переменные и константы абстрактной спецификации

В TLA+ есть константы и переменные. Константы задаются для модели извне и не меняются для всего графа состояний. А значения переменных, наоборот, позволяют различить вершины графа. Они меняются в переходах, разрешённых в модели. Переменные абстрактной модели представлены на листинге 1.

```
Листинг 1 - константы и переменные абстрактной спецификации

CONSTANTS Replica, Quorum

\* Replica Status
CONSTANTS Normal, ViewChange, Recovering

\* Client operation
CONSTANT Operation

\* types of log blocks
CONSTANTS RequestBlock, ViewBlock

\* Special value
CONSTANT None

\* Sequence with all replicas (for view selection)
CONSTANT ReplicaSequence

\* State on each replica
VARIABLE replicaState

vars == <<replicaState>>
```

Replica - это множество модельных значений, соответствующих репликам. Например, если `Replica = {r1, r2, r3}`, значит, у нас есть 3 реплики, к которым можно обращаться, как r1, r2, r3. Quorum - множество всех кворумов, то есть подмножеств реплик таких, что каждый с каждым пересекается хотя бы по одной. Обычно для трёх реплик это `{{r1, r2}, {r2, r3}, {r1, r3}}`. Дальше идут константы для обозначения статусов реплики. Operation - это множество операций к движкам, которые мы и реплицируем на машинах. Можно абстрактно обозначить, как `{o1, o2}`. Именно 2 значения, потому что когда мы будем проверять согласованность журналов на разных машинах, мы сможем различить одинаковые операции хранятся на одной позиции или нет. Для этого хватает и двух значений. Если существуют некорректные исполнения с тремя разными запросами, в которых нарушается консистентность логов, то существует исполнение и с двумя, в котором это нарушение обнаружится. RequestBlock, ViewBlock - константы для различения в журнале запросов к движкам и View блоков. None это специальное значение, не равное ничему другому. ReplicaSequence это порядок реплик для выборов. Например, `[r1, r2, r3]`. И единственная переменная - replicaState - обозначает состояния всех нод. Её возможные значения будут специфицированы далее.

## 2.2.2 Типовой инвариант и предположения абстрактной модели

В TLA+ принято обозначать инвариант с допустимыми типами для переменных как TypeOK. Для данной спецификации приведён типовый инвариант на листинге 2.

```
Листинг 2 - типы и предположения

Statuses == {Normal, ViewChange, Recovering}

LogEntry == [type: {RequestBlock}, opNumber: Nat, op: Operation]
       \cup [type: {ViewBlock}, view: Nat]

TypeOK == /\ replicaState \in [
            Replica -> [
                viewNumber: Nat,
                status: Statuses,
                log: Seq(LogEntry),
                downloadReplica: Replica \cup {None},
                commitNumber: Nat
              ]
            ]

ASSUME QuorumAssumption == /\ \A Q \in Quorum : Q \subseteq Replica
                           /\ \A Q1, Q2 \in Quorum : Q1 \cap Q2 # {} 

ASSUME IsFiniteSet(Replica)
```

Statuses задаёт множество возможных статусов реплики. Все значения - константы модели.

LogEntry обозначает множество возможных элементов лога. Это либо структура с полями type, opNumber и op, либо с полями type и view. В первом случае type принимает значение из множества `{RequestBlock}` (то есть всегда равен RequestBlock), opNumber из множества Nat (натуральные числа и 0), op из множества Operation (мы его задавали, как константа модели). Во втором случае type всегда ViewBlock, а view - число из Nat.

В TypeOK записано утверждение, что replicaState - это функция из реплики в структуру с полями viewNumber, status, log, downloadReplica, commitNumber; их множества допустимых значений указаны рядом с ними. Стоит отметить, что `Seq(LogEntry)` обозначает последовательность из LogEntry.

Когда мы будем запускать модель, то будем ставить TypeOK инвариантом - то есть утверждением, которое должно быть истинным во всех допустимых состояниях модели. TLC model checker будет проверять это во всех вершинах графа состояний.

QuorumAssumption утверждает, что все элементы из Quorum должны быть подмножеством реплик, и что все они должны попарно пересекаться. Это и есть определение кворума. Ключевое слово ASSUME означает предположение, которое должно выполняться для модели. TLC проверит его и сообщит, если оно нарушается.

Утверждение `IsFiniteSet(Replica)` говорит, что Replica - не бесконечное множество; если оно нарушается, то TLC будет бесконечно пробовать выполнить почти любое действие и проверка будет бессмысленна.

## 2.2.3 ... абстрактной спецификации

```
Листинг 3 - ...

Init == /\ replicaState = [r \in Replica |-> [
                    viewNumber |-> 0,
                    status |-> Normal,
                    log |-> << [type |-> ViewBlock, view |-> 0] >>,
                    downloadReplica |-> None,
                    commitNumber |-> 0
                ]
           ]

AddClientRequest(r, m) ==
    /\ replicaState' = [replicaState EXCEPT ![r].log = Append(@, m)]

RecieveClientRequest(p, op) ==
    /\ IsPrimary(p)
    /\ Status(p) = Normal
    /\ ~IsDownloading(p)
    /\ AddClientRequest(p, [type |-> RequestBlock,
                            opNumber |-> OpNumber(p) + 1,
                            op |-> op])
```

На листинге 3 приведён Init - традиционное обозначение начального состояния модели - и RecieveClientRequest - пример возможного перехода. В Init записано утверждение про значение полей replicaState для всех машин - viewNumber равно нулю, статус Normal, в логе одна запись про начало view с номером 0, downloadReplica (реплика, с которой мы скачиваем) никакая, commitNumber равно нулю.

RecieveClientRequest показывает, как обычно выглядят переходы в модели. Это дизъюнкция утверждений двух типов: предикатов действия и новых значений переменных. Дизъюнкты `IsPrimary(p)`, `Status(p) = Normal` и `~IsDownloading(p)` - предикаты. Действие может выполнится в каком-то состоянии мира, если они все равны True. Первое обозначает, что реплика p сейчас лидер своего view, второе говорит, что её статус Normal, третье - p ничего не скачивает (её downloadReplica равно None). AddClientRequest можно назвать макросом, вместо которого подставится его определение, данное в этом же листинге 3. В нём один дизъюнкт, который уже является утверждением про новое значение переменной replicaState. В этом специфическом синтаксисе TLA+ записано, что новое значение списка `replicaState[r].log` станет равно старому, к которому добавили (`Append(@, m)`) структуру m.

Само значение структуры m - `[type |-> RequestBlock, opNumber |-> OpNumber(p) + 1, op |-> op]`. Остаётся вопрос, откуда берётся значение реплики p и операция op в параметрах перехода RecieveClientRequest.

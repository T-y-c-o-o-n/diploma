# Глава 2. Tla+ cпецификации

Для проверки корректности алгоритма репликации движков необходимо написать спецификацию на TLA+. В введении было сказано про проблемы у спецификаций и соответствующих им TLC моделей. Во-первых, описание системы на языке TLA+ может быть слишком абстрактным и не похожим на реальный код. Во-вторых граф состояний в TLC модели может быть слишком большим из-за, наоборот, очень подробной модели. Поэтому хочется написать 2 спецификации, детальную для большего соответствия коду, и абстрактную, для проверки свойств.

## 2.1. Различия спецификаций

Хочется, чтобы абстрактная модель задавала то, что происходит в системе. Например, мастер добавляет новый запрос пользователя, реплика копирует с мастера этот запрос, или нода становится лидером, выбирая лучшую цепочку. А детальная спецификация должна показывать то, как это происходит. Одна декларативно описывает "что", вторая описывает "как".

Основная идея состоит в том, чтобы в абстрактной спецификации не было сообщений между репликами, а в детальной они были. Тогда в первой переменные с состояними машин будут обмениваться значениями друг с другом - реплики копировать лог мастера, например - а вторая будет отвечать на вопрос, как они это делают - через сообщения.

## 2.2 Абстрактная спецификация

Вначале приведу абстрактную спецификацию.

## 2.2.1 Переменные абстрактной спецификации

В TLA+ есть константы и переменные. Константы задаются для модели извне и не меняются для всего графа состояний. А значения переменных, наоборот, позволяют различить вершины графа. Они меняются в переходах, разрешённых в модели. Переменные абстрактной модели представлены на листинге 1.

```
Листинг 1 - константы и переменные абстрактной спецификации

CONSTANTS Replica, Quorum

\* Replica Status
CONSTANTS Normal, ViewChange, Recovering

\* Client operation
CONSTANT Operation

\* types of log blocks
CONSTANTS RequestBlock, ViewBlock

\* Special value
CONSTANT None

\* Sequence with all replicas (for view selection)
CONSTANT ReplicaSequence

\* State on each replica
VARIABLE replicaState

vars == <<replicaState>>
```

Replica - это множество модельных значений, соответствующих репликам. Например, если `Replica = {r1, r2, r3}`, значит, у нас есть 3 реплики, к которым можно обращаться, как r1, r2, r3. Quorum - множество всех кворумов, то есть подмножеств реплик таких, что каждый с каждым пересекается хотя бы по одной. Обычно для трёх реплик это `{{r1, r2}, {r2, r3}, {r1, r3}}`. Дальше идут константы для обозначения статусов реплики. Operation - это множество операций к движкам, которые мы и реплицируем в логах. Можно абстрактно обозначить, как `{o1, o2}`. Именно 2 значения, потому что когда мы будем проверять согласованность журналов на разных машинах, мы сможем различить одинаковые операции хранятся на одной позиции или нет. Для этого хватает и двух значений. Если существуют некорректные исполнения с тремя разными запросами, в которых нарушается консистентность логов, то существует исполнение и с двумя, в котором это нарушение обнаружится. RequestBlock, ViewBlock - константы для различения в журнале запросов к движкам и View блоков. None это специальное значение, не равное ничему другому. ReplicaSequence это порядок реплик для выборов. Например, `[r1, r2, r3]`. И единственная переменная - replicaState - обозначает состояния всех нод. Её возможные значения будут специфицированы дальше.

В TLA+ принято обозначать инвариант с допустимыми типами для переменных как TypeOK. Для данной спецификации приведён типовый инвариант на листинге 2.

```
Листинг 2 - типы и предположения

LogEntry == [type: {RequestBlock}, opNumber: Nat, op: Operation]
       \cup [type: {ViewBlock}, view: Nat]

TypeOK == /\ replicaState \in [
            Replica -> [
                viewNumber: Nat,
                status: Statuses,
                log: Seq(LogEntry),
                downloadReplica: Replica \cup {None},
                commitNumber: Nat
              ]
            ]

ASSUME QuorumAssumption == /\ \A Q \in Quorum : Q \subseteq Replica
                           /\ \A Q1, Q2 \in Quorum : Q1 \cap Q2 # {} 

ASSUME IsFiniteSet(Replica)
```


